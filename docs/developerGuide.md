Developer guide
===============
## Table of contents
- [Introduction](#introduction)
- [Configuration](#configuration)
- [Folder structure of BLT2](#structure)
- [phpDocs](#phpdocs)
- [Routing](#routing)
- [Templating](#templating)
- [CSS](#css)
- [JavaScript](#js)
- [API](#api)

## <a name="introduction"></a>Introduction
This guide is a walkthrough on how to use BLT2's API along with additional information about the application.

## <a name="configuration"></a>Configuration
All configuration settings are in ```/app/config```. Most of the values in ```config.yml``` are imported from ```parameters.yml```. This file is automatically generated when you first set up BLT2 and is excluded from the repository. To make any changes that involve syntax such as ```"%database_name%"```, please update them in ```parameters.yml```.
 
## <a name="structure"></a>Folder structure of BLT2
A quick overview of the folder structure of BLT2 (and in Symfony in general) can be found [here](http://symfony.com/doc/current/quick_tour/the_architecture.html).

Controllers for BLT2 are located in ```/src/AppBundle/Controller```. The ```API``` folder holds all functionality for BLT2's API while the ```Frontend``` folder holds all functionality for routing.

BLT2 uses [Twig](http://twig.sensiolabs.org) templating to generate its HTML prior to sending it back to the user as a response. These templates reside in ```/app/Resources/views```. The ```blocks``` folder contains reusable Twig templates and are used throughout BLT2 for code reusability.

All CSS (LESS), images, fonts, and JavaScript are located ```/web/css```, ```/web/images```, ```/web/fonts```, and ```/web/js``` respectively. CSS are stored in .less files and are compiled using LESS. Any changes to the .less files will require recompiling by using the command ```$ php bin/console assetic:dump``` in terminal. **The same applies to all JavaScript files.**

## <a name="phpdocs"></a>phpDocs
phpDocs have been generated for the controllers (API and frontend) and entities and are located in ```/docs/phpdocs```. You can view the docs by opening ```index.html``` in a browser.

## <a name="routing"></a>Routing
BLT2 uses [Symfony's routing class](http://symfony.com/doc/current/book/routing.html), using the special ```@Routing``` tag in the comments, to store which routes points to which controller/action. This is different from BLT1 in which all routes were stored in ```/src/BUNDLE/Resources/config/routing.yml```. This allows each function to have an associated route attached to it in the php file instead of decoupling it in a different file.

For example:
```php
/**
 * Route to render the main menu page
 *
 * @Route("/", name="menu")
 */
public function renderTemplateAction() {
    ...
}
```
The ```@Routing``` tag in the comment tells Symfony what route goes to this function and the name of this route for debugging purposes.

There's also a special ```@Method``` tag that tells Symfony what type of HTTP request can be made to that specific function.
   
For example:
```php
/**
 * Route for creating a new Package
 *
 * ...
 *
 * @Route("/packages/new", name="newPackage")
 * @Method({"POST"})
 */
 public function newPackageAction(Request $request) {
    ...
 }
```
The ```@Method``` tag in the comment tells Symfony that only POST requests are allowed to this function within this controller.

Some routes can have placeholders within its route.

For example:
```php
/**
 * Route for enabling a Vendor
 *
 * @api
 *
 * @param string $id Vendor's ID
 *
 * @return JsonResponse Results of the call
 * 
 * @Route("/vendors/{id}/enable", name="enableVendor")
 * @Method({"PUT"})
 */
public function enableVendorAction($id) {
    ...
}
```
The ```{id}``` placeholder in the ```@Route``` tag along with the ```$id``` variable in the function parameter allows the function to use what was given in the URL as an argument within its function. This is especially useful for BLT2's API.

## <a name="templating"></a>Templating
Symfony uses Twig templating to generate web pages before sending it back to the user. Templating allows a "hierarchical approach" in how a web pages are generated before sending it back as response and are located in ```/app/Resources/views```. With each controller defined in the Frontend folder (except BaseController.php), there is a template associated with it.

For example:
```php
/**
 * Route to render the delivering page
 *
 * @Route("/delivering", name="delivering")
 */
public function renderTemplateAction() {
    return $this->render('delivering.html.twig');
}
```
Each frontend controller (except BaseController.php) has a ```renderTemplateAction()``` function that, along with a route, tells Symfony that if a user visits /delivering in a web browser, render ```deliverying.html.twig```.

Almost all templates extend from ```base.html.twig```. In this template, you'll see that all of the base HTML tags has been defined and see that most of it are in blocks. Blocks, defined as ```{% block _blocktitle_ %}```, allows the hierarchical approach in templating. As we move on from ```base.html.twig``` to other templates, you'll see that the majority of HTML tags resides in a block.

For example (entity.html.twig):
```twig
{% extends 'base.html.twig' %}

{% block userActions %}
    <li><a href="/" tabindex="-1">Back to menu</a></li>
{% endblock %}

{% block stylesheets %}
    {{ parent() }}

    {% stylesheets
    'css/entity.less' filter='cssrewrite' %}
    <link rel="stylesheet" type="text/css" href="{{ asset_url }}" />
    {% endstylesheets %}
{% endblock %}

{% block body %}
    <div class="container">
        <div class="row">
        {% if entity %}
            {% if type == "receiver" %}
                <h2>{{ entity.name }} - {{ entity.deliveryRoom }}</h2>
            {% elseif type == "package" %}
                <h2>{{ entity.trackingNumber }}</h2>
            {% else %}
                <h2>{{ entity.name }}</h2>
            {% endif %}
        {% else %}
            <h2>No such entity</h2>
        {% endif %}
        </div>
    </div>
{% endblock %}

{% block javascripts %}
    {{ parent() }}

    {% javascripts
    'js/entity.js' %}
    <script type="text/javascript" src="{{ asset_url }}"></script>
    {% endjavascripts %}
{% endblock %}
```
1) ```menu.html.twig``` extends from ```base.html.twig```
2) ```{% block userActions %}``` contains all the HTML links that are listed towards the upper right corner of the web application
3) ```{% block stylesheets %}``` contains all the links to the stylesheets used for this page, along with a ```{{ parent() }}``` call to render everything in the same block from the parent template (in this case, from ```base.html.twig```)
4) ```{% block body %}``` contains all of the HTML for this page
5) ```{% block javascripts %}``` contains all the links to the javascript files used for this page, along with a ```{{ parent() }}``` call to render everything in the same block from the parent template (in this case, from ```base.html.twig```) 

You can also have logic in Twig templating.

For example:
```twig
{% if type == "receiver" %}
    <h2>{{ entity.name }} - {{ entity.deliveryRoom }}</h2>
{% elseif type == "package" %}
    <h2>{{ entity.trackingNumber }}</h2>
{% else %}
    <h2>{{ entity.name }}</h2>
{% endif %}
```

If the ```type``` variable is set, then follow logic to render HTML tags. Variables can be set either within the Twig template themselves prior to using it or from the controller that is rendering it.

For example:
```php
/**
 * Route to display Receiver's information
 *
 * @api
 *
 * @param string $id Receiver's ID
 *
 * @return Response Render twig template with Receiver Information
 *
 * @Route("/receivers/{id}", name="receiver")
 * @Method({"GET"})
 */
public function receiverAction($id) {
    // Get the Receiver repository
    $receiverRepository = $this->getDoctrine()->getRepository("AppBundle:Receiver");

    $receiver = $receiverRepository->find($id);

    return $this->render('entity.html.twig', [
        "type" => "receiver",
        "entity" => $receiver
    ]);
}
```
Here, at the end of the ```receiverAction($id)``` function where the Twig template is being rendered and returned, it passes onto the templating engine the variables ```type``` and ```entity```. 


## <a name="css"></a>CSS(LESS)
BLT2 uses Bootstrap 3 for the majority of its CSS thus only a few templates need additional CSS. For those templates that need additional CSS, they are coupled with a .less file and are usually named after their template. All of the CSS(LESS) files are located in ```/web/css```. 

For example (menu.html.twig):
```
{% block stylesheets %}
    {{ parent() }}
    {% stylesheets
    'css/blt2/menu.less' %}
    <link rel="stylesheet" type="text/css" href="{{ asset_url }}" />
    {% endstylesheets %}
{% endblock %}
```
Here, the ```menu.html.twig``` needs ```menu.less``` for additional CSS.

BLT2 uses LESS in conjunction with Bootstrap's breakpoints to help better control how things look based on what device is being used.
 
For example (menu.less):
```css
@import "../breakpoints";

/* Extra small devices (phones, less than 768px) */
/* No media query since this is the default in Bootstrap */

#menu {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 50px;
}

#deliveringDiv {
    margin-top: 40px;
}

.menuMainButtons {
    font-size: 50px;
}

/* Small devices (tablets, 768px and up) */
@media (min-width: @screen-sm-min) {
    #menu {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 25%;
    }

    #deliveringDiv {
        margin-top: 40px;
    }

    .menuMainButtons {
        font-size: 50px;
    }
}

/* Medium devices (desktops, 992px and up) */
@media (min-width: @screen-md-min) {
    #menu {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 20%;
    }

    #deliveringDiv {
        margin-top: 0;
    }

    .menuMainButtons {
        font-size: 50px;
    }
}

/* Large devices (large desktops, 1200px and up) */
@media (min-width: @screen-lg-min) {  }
```

At each breakpoint, defined by Bootstrap, use a different group of CSS rules. Again, additional CSS are only use to have a greater control of how things are displayed on top of Bootstrap.

**Any changes to these .less files require them to be compiled to CSS by using ```$php bin/console assetic:dump```.**

## <a name="js"></a>JavaScript
A lot of the functionality of BLT2 comes from JavaScript (more specifically, jQuery) and [AJAX](https://developer.mozilla.org/en-US/docs/AJAX) ($.get, $.post, $.ajax for jQuery). AJAX allows a website to behave like an application by allowing it to send and retrieve data to the server without refreshing the web page. Similar to CSS(LESS) files, JavaScript files are located in ```/web/js``` and are named after the template which requires them. 

jQuery is used throughout (as required by Bootstrap for their JS functionality) BLT2 and the majority of the JS code resides under ```$(document).ready(function() { ... });```. BLT2 also uses a number of third-party, open-sourced libraries to help facilitate the application such as [Charts.js](http://www.chartjs.org), [DataTables](https://datatables.net) and [Select2](http://select2.github.io).

Here is an example from ```maintenance.js``` that, when the enable/disable button has been click, make a call to the server to enable/disable Receiver.
```javascript
// When the user click a button within the receiver table, enable or disable the receiver
$('.receiver').click(function() {
    // Get the button that launched the modal
    var receiver = $(this);

    // Get the clicked button's id
    var id = receiver.data('id');
    // Get the clicked button's value
    var action = receiver.data('action');

    if (id !== "" && id !== undefined && id !== null && action.replace(/\s/g) !== "" && action !== undefined && action !== null) {
        // Make the AJAX call to the server to switch the on or off the receiver
        $.ajax({
            type: "PUT",
            url: "receivers/" + id + "/" + action.toLowerCase()
        })
            .done(function(results) {
                // If the results are successful, change the color and text within the button to reflect the change
                if (results['result'] == 'success') {
                    if (action ==='enable') {
                        receiver.text("Disable");
                        receiver.removeClass("btn-success");
                        receiver.addClass("btn-danger");
                        receiver.data('action', 'disable');
                    } else {
                        receiver.text("Enable");
                        receiver.removeClass("btn-danger");
                        receiver.addClass("btn-success");
                        receiver.data('action', 'enable')
                    }
                }
            })
            .fail(function() {
                // Display an alert saying that there was an issue with the AJAX call
                $("#errorModalText").text("There was an connection error; please try again");
                $("#errorModal").modal('show');
            });
    } else {
        // Display an alert saying that there was an issue getting data from button
        $("#errorModalText").text("Unable to determine Receiver's ID and/or action");
        $("#errorModal").modal('show');
    }

});
```


**Any changes to these .js files require them to be compiled into a single file, BLT2.js, by using ```$php bin/console assetic:dump```.**
## <a name="api"></a>API